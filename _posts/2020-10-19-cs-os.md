---
layout: post
title: "운영체제 전체 정리"
subtitle: "운영체제 주요 개념 정리"
categories: cs
tags: OS os 운영체제 interview 면접
comments: true
---

## 메모리 영역

* **스택영역**
  * 지역변수, 매개변수
  * 컴파일 타임에 크기가 결정됨.
  * 너무 많아 힙영역을 침범하는 경우 : Stack Overflow
* 힙영역
  * 동적할당된 메모리,변수
  * 런타임에 크기가 결정됨
  * 너무 많아 스택영역을 침범하는 경우 : Heap Overflow
* **데이터영역**
  * 전역변수, 정적변수
* **bss영역**
  * 초기화되지 않은 전역 데이터를 위한 영역
  * 실제 변수가 차지할 공간이 할당되지 않으므로 바이너리 크기가 절약된다.
* **코드영역**
  * 실행할 프로그램의 코드.



## 이중 동작모드 Dual-mode Operation

### 이중 동작모드란?

사용자의 중요한 시스템 자원 직접접근을 제한하여 운영체제를 보호하기 위한 기법.

### 커널모드란 ? 

* 시스템의 **모든 메모리에 접근** 할 수 있고 **모든 CPU명령을 실행** 할 수 있다.
* 수퍼바이저 모드(supervisor mode), 시스템 모드(system mode), 특권모드(privileged mode) 로도 불리운다.

### 유저모드란?

- 시스템 데이터에 **제한된 접근만이 허용**되며 하드웨어를 **직접 접근할 수 없다**.
- 유저 애플리케이션은 시스템 서비스 호출을 하면 유저모드에서 커널모드로 전환된다.

### 이중 동작 모드의 구조

- ![img](https://camo.githubusercontent.com/252f8f51bfd5417a7ed7eba46fc0ef125cab5565/68747470733a2f2f6b2e6b616b616f63646e2e6e65742f646e2f45694f6e782f6274714444766e486a717a2f3570774b624266723935734276746b726f654a63444b2f696d672e706e67)
- 사용자가 사용하는 응용프로그램은 유저 모드에서 작동이 되어지게 한다.
- 해당 프로그램이 운영체제에게 시스템 사용을 요청하게 되면 커널모드로 바꾸어서 요청된 시스템을 실행
- 다시 사용자 모드로 전환



### 모드비트란? 

이 커널모드와 사용자 모드를 구분짓기 위해 **모드 비트(mode bit)** 라고 하는 하나의 비트가 컴퓨터의 하드웨어에 추가 되었는데. 이비트는 **커널모드(0)과 유저모드(1)** 을 나타낸다. 모드비트의 사용으로 우리는 **운영체제를 위하여 실행되는 작업과 사용자를 위해 실행되는 작업을 구분**할 수 있다.

- 시스템 부팅시 하드웨어는 커널모드에서 시작되는데 그 다음 운영체제가 적재되고 유저모드에서 사용자프로세스가 시작되게 한다. 트랩이나 인터럽트가 발생할때마다 하드웨어는 커널모드로 전환하게 된다. 그래서 대표적으로 컴퓨터가 제어를 얻을때 마다 항상 커널모드로 있게 된다.
- 유저모드에서 불법적인 명령을 실행하게 되면 하드웨어는 운영체제로 트랩을 발생시키게 되면서 커널모드에 접근할 수 없다.



> ## Q . 인터럽트와 트랩의 차이점?
>
> 소프트웨어 인터럽트를 트랩이라고 한다.



### 모드의 변화 과정

1. 컴퓨터 부팅 과정 - 커널 모드

2. 애플리케이션 실행 과정 - 커널 모드

3. 애플리케이션 실행중 - 유저 모드

4. 인터럽트 발생 후 처리 과정 - 커널 모드

   (하드웨어 인터럽트라 가정시)

   1. 하드웨어 인터럽트 발생후 CPU로 인터럽트 신호 요청 (유저모드)
   2. CPU에서 모드 플래그를 커널모드 값(0)으로 변경
   3. 해당 하드웨어 인터럽트 서비스 루틴(ISR)으로 이동 (커널 모드)
   4. 인터럽트 처리 (커널모드)
   5. 인터럽트 처리 완료 후 CPU의 모드 플래그를 다시 유저모드 값(1)으로 변경
   6. 원래의 애플리 케이션 위치로 복귀 (유저모드) -> 상위 5번과정.

5. 인터럽트 처리 후 - 유저 모드



> Q. 인터럽트 서비스 루틴(ISR) 이란 ? 
>
> 인터럽트에 대응하여 특정기능을 처리하는 기계어 코드 루틴. 
> (인터럽트 대응 메뉴얼이라고 생각함) 



## 인터럽트

### 인터럽트란

CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것을 말한다.
인터럽트는 크게 하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉜다.



### 왜필요하죠?

CPU 가 하는 일을 멈춘채로 입출력 연산을 기다리게되면 오버헤드가 크다. 그래서 CPU가 일을 하게 둔채로 입출력 연산을 진행해야 될때 인터럽트를 통해 CPU에게 알려주게 되면 좀더 CPU자원을 효율적으로 사용할 수 있게 된다.



## 프로세스와 스레드

### 프로그램이란

어떤 작업을 위해 실행할 수 있는 파일, 실행가능한 명령어의 집합

### 프로세스란

- 사전적의미
  - 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
  - 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
  - 운영체제로부터 시스템 자원을 할당받는 작업의 단위
- 특징
  - 프로세스는 각각 독립된 메모리영역(Code, Data, Stack,Heap의 구조)을 할당 받는다.
  - 기본적으로 프로세스당 최소 1개의 스레드를 가지고 있다.
  - 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
  - 한프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, Inter-process communication)을 사용해야한다.

### 스레드란?

사전적 의미

- 프로세스 내에서 실행되는 여러 흐름의 단위

특징

- 스레드는 프로세스 내에서 스택만 따로 할당 받고 code, data, heap 영역은 공유한다.
- 스레드는 한 프로세스 내에서 동작되는 여러 실행 흐름으로, 프로세스 내의 주소 공간이나 자원들을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다.

## 멀티 프로세스와 멀티 스레드의 차이

#### 멀티프로세싱이란

- 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(태스크)을 처리하도록 하는 것이다.
- 장점
  - 여러개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않는다.
- 단점
  - Context Switching에서의 오버헤드
    - Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생하게 된다.
    - 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어, Context Switching 이 발생하면 캐쉬에 있는 모든 데이터를 모두 리셋하고 다시 캐쉬 정보를 불러와야 한다.

> #### Context Switching이란?
>
> 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태(Context)를 보관하고, 대기하고있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 말한다.

#### 멀티 스레딩이란

- 하나의 응용프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는것이다.
- 장점
  - 시스템 자원 소모 감소 (자원의 효율성 증대)
    - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
  - 시스템 처리량 증가(처리비용 감소)
    - 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.
    - 스레드 사이의 작업량이 작아 Context Switching이 빠르다.
  - 간단한 통신 방법으로 인한 프로그램 응답 시간 단축
    - 스레드는 프로세스 내의 Stack영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적다.
- 단점
  - 멀티 스레드의 경우 자원 공유의 문제가 발생한다.
  - 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.

### 멀티 프로세스 대신 멀티 스레드를 사용하는 이유?

- 멀티 프로세스 대신 멀티 스레드를 사용하는 것의 의미?
  - 프로그램을 여러개 키는 것 보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이다.
- 여러 프로세스(멀티 프로세스)로 할 수있는 작업들을 하나의 프로세스에서 여러 스레드로 나눠가면서 하는 이유?
  - 자원의 효율성 증대
    - 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
    - 프로세스 간의 Context Switching 시 단순히 CPU 레지스터 교체 뿐만 아니라 RAM과 CPU 사이의 캐쉬 메모리에 대한 데이터까지 초기화되므로 오버헤드가 크기 때문.
    - 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.
  - 처리 비용 감소 및 응답시간 단축
    - 프로세스 간의 통신보다 스레드 간의 통신 비용이 적으므로 작업들 간의 통신부담이 줄어든다
      - 스레드는 스택영역을 제외한 모든 메모리를 공유하기때문에
    - 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다.
      - Context Switching시 스레드는 Stack영역만 처리하기 때문.
- 주의
  - 스레드간의 자원 공유는 전역변수를 이용하므로 함께 사용할때 충돌이 발생할 수 있다. 동기화문제.

## 쓰레드 세이프

### 쓰레드 세이프란?

멀티 쓰레드 프로그래밍에서 어떤 함수, 변수, 객체가 여러 쓰레드로 부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 뜻함.

### Critical Section 이란?

동일한 작업을 동시에 접근하는 작업을 실행하는 코드 영역.

 한 프로세스가 이 임계구역에서 수행하는 동안 다른 프로세스는 들어갈 수 없어야 함.

### Critical Section의 3요소

1. **mutual exclusion (상호배제)** : 특정한 프로세스가 임계구역에서 실행되는 동안, 다른 프로세스가 접근 할 수 없다.
2. **progress (진행)** : 임계구역을 사용하지 않고 있다면, 다른 프로세스가 접근할 수 있도록 한다.
3. **bounded waiting(한정된 대기)** : 임계구역 진입 횟수에 한계가 있어서 같은프로세스가 계속 독점해서 사용하지 못하게 한다. 다른 프로세스들이 기아(starvation)에 빠지지 않도록 한다.



## 뮤텍스 & 세마포어

### 공통점

**"여러 프로세스나 쓰레드가 공유 자원에 접근하는 것을 제어하기 위한 방법"**

즉, **병행 처리를 위한 프로세스 동기화 기법**입니다.

### 뮤텍스와 세마포어의 차이점

- 세마포어는 공유 자원에 **세마포어의 변수만큼의 프로세스(또는 쓰레드)가 접근**할 수 있습니다. 반면에 뮤텍스는 **오직 1개만의 프로세스(또는 쓰레드)만 접근**할 수 있습니다.
- 현재 수행중인 프로세스가 아닌 **다른 프로세스가 세마포어를 해제할 수 있습니다.** 하지만 뮤텍스는 **락(lock)을 획득한 프로세스가 반드시 그 락을 해제**해야 합니다.



### 동기화와 관련한 고전적인 문제



✓ **은행 계좌 문제 (Back Account Problem)**

- 부모는 은행 계좌에 입금을 한다. 자식은 은행 계좌에서 출금한다.
- 입금과 출금 과정이 별도로 이루어져야 한다.
- **크리티컬 섹션** : 은행 계좌



✓ **독자 저자 문제 (Readers Writers Problem)**

- 독자는 책(공유 데이터베이스)에 쓰여있는 글을 읽는다. 저자는 책에 글을 써서 추가한다.
- 독자가 글을 읽고 있다면, 독자는 추가적으로 글을 읽을 수 있지만, 저자는 글을 쓸 수 없다.
- 저자가 글을 쓰고 있다면, 독자는 글을 읽을 수 없으며, 저자 또한 추가적으로 글을 쓸 수 없다.
- **크리티컬 섹션** : 책 (공유 데이터베이스)



✓ **생산자 소비자 문제 (Producer Consumer Problem)**

- 한정 버퍼 문제(Bounded Buffer Problem)라고도 한다.
- 생산자는 물건을 생산하여 창고(버퍼)에 넣는다. 소비자는 창고에서 물건을 꺼내서 소비한다.
- 창고가 가득 차면 생산자는 물건을 넣을 수 없고, 창고가 비어 있으면 소비자는 물건을 소비할 수 없다.
- **크리티컬 섹션** : 창고 (버퍼)



✓ **식사하는 철학자 문제 (Dining Philosopher Problem)**

- 원형 테이블에 철학자들이 앉아있고 철학자의 수만큼 젓가락이 철학자 사이에 하나씩 놓여있다.
- 철학자들이 식사를 하기 위해서는 양쪽에 하나씩 놓여있는 젓가락을 둘 다 들어서 사용해야 한다.
- 어떤 철학자가 젓가락을 사용 중이라면, 다른 어떤 철학자는 식사를 할 수 없다.
- **크리티컬 섹션** : 젓가락



## 데드락

## 데드락의 개념

\- 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로, ‘교착 상태’라고도 하며 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생합니다.

[![img](https://camo.githubusercontent.com/9171e4e07254572aaa056463c353e7d220b0a391/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323433453839333535373134433236453238)](https://camo.githubusercontent.com/9171e4e07254572aaa056463c353e7d220b0a391/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323433453839333535373134433236453238)

## 데드락 (Dead lock)의 발생 조건

1. **상호 배제 (Mutual exclusion)**

- 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.

1. **점유 대기 (Hold and wait)**

- 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.

1. **비선점 (No preemption)**

- 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.

1. **순환 대기 (Circular wait)**

- 프로세스의 집합 {P0, P1, ,…Pn}에서 P0는 P1이 점유한 자원을 대기하고 P1은 P2가 점유한 자원을 대기하고 P2…Pn-1은 Pn이 점유한 자원을 대기하며 Pn은 P0가 점유한 자원을 요구해야 한다.



## 데드락 처리방법

### 교착상태 예방 (Prevention)

\- 교착 상태 발생 조건 중 하나를 제거함으로써 해결하는 방법

\- 자원의 낭비가 심하다.

| **상호 배제 (Mutual exclusion) 부정** | - 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다. (하지만 동기화 문제가 다시 나타날 듯) |
| ------------------------------------- | ------------------------------------------------------------ |
| **점유 대기 (Hold and wait) 부정**    | - 프로세스가 실행되기 전 필요한 모든 자원을 할당한다. (이미 모든 자원을 가진 채 시작하여 다른 자원을 wait할 필요가 없다) |
| **비선점 (No preemption) 부정**       | - 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구한 자원을 사용하기 위해 기다리게 한다. |
| **순환 대기 (Circular wait) 부정**    | - 자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 한다. |

### 교착상태 회피 (Avoidance)

교착상태 회피 기법은 교착상태가 발생할 가능성을 배제하지 않고 교착상태가 발생하면 적절히 피해나가는 방법으로, 주로 은행원 알고리즘(Banker's Algorithm)이 사용됩니다.

**은행원 알고리즘**

**1.** 은행원 알고리즘은 다익스트라가 제안한 기법으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래한 기법입니다.

**2.** 각 프로세스에게 자원을 할당하여 교착상태가 발생하지 않으며 모든 프로세스가 완료될 수 있는 상태를 안전상태, 교착상태가 발생할 수 있는 상태를 불안전 상태라고 합니다.

**3.** 은행원 알고리즘을 적용하기 위해서는 자원의 양과 사용자(프로세스) 수가 일정해야 합니다.

**4.** 은행원 알고리즘은 프로세스의 모든 요구를 유한한 시간안에 할당하는 것을 보장합니다.

> 요약하자면 줄수있는 애한테 주는 방법.

### 교착상태 발견 (Detection)

교착상태 발견 기법은 시스템에 교착상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견하는 것을 의미합니다.

1. 교착상태 발견 알고리즘과 자원 할당 그래프 등을 사용 할 수 있습니다.
2. 변형된 Bankers 알고리즘을 사용할 수 있습니다 (bankers가 할당되지 않은 자원을 할당시키는 시뮬레이션으로 데드락을 탐지한다면, 여기서는 실제로 자원을 할당시켜놓고 bankers와 유사하게 시뮬레이션 하면 된다.)

### 교착상태 회복 (Recovery)

교착상태 회복 기법은 교착상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것을 의미합니다.

**프로세스 종료**

교착상태에 있는 프로세스를 종료하는 것으로, 교착상태에 있는 모든 프로세스를 종료하는 방법과 교착상태에 있는 프로세스들을 하나씩 종료해가며 교착상태를 해결하는 방법이 있습니다.

**자원선점**

교착상태의 프로세스가 점유하고 있는 자원을 선점하여 다른 프로세스에게 할당하며, 해당 프로세스를 일시 정지시키는 방법입니다. 우선순위가 낮은 프로세스, 수행된 정도가 적은 프로세스, 사용되는 자원이 적은 프로세스 등을 위주로 해당 프로세스의 자원을 선점합니다.

**※ 자원 선점시 고려사항**

**1.** 자원 을 선점할 프로세스 선택 문제 : 최소의 피해를 줄 수 있는 프로세스를 선택합니다.

**2.** 자원을 선점한 프로세스의 복귀 문제 : 자원이 부족한 상태이므로 대부분 일시 중지시키고 다시 시작하는 방법을 사용합니다.

**3.** 기아 현상 문제 : 한 프로세스가 계속하여 자원 선점 대상이 되지 못하도록 고려해야 합니다.