---
layout: post
title: "[2019 카카오 겨울 인턴십] 튜플"
subtitle: "2019 카카오 겨울 인턴십 2번문제"
categories: algorithm
tags: programmers java algorithm
comments: true

---

# 문제설명

셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.

- (a1, a2, a3, ..., an)

튜플은 다음과 같은 성질을 가지고 있습니다.

1. 중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)
2. 원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2)
3. 튜플의 원소 개수는 유한합니다.

원소의 개수가 n개이고, **중복되는 원소가 없는** 튜플 `(a1, a2, a3, ..., an)`이 주어질 때(단, a1, a2, ..., an은 자연수), 이는 다음과 같이 집합 기호 '{', '}'를 이용해 표현할 수 있습니다.

- {{a1}, {a1, a2}, {a1, a2, a3}, {a1, a2, a3, a4}, ... {a1, a2, a3, a4, ..., an}}

예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는

- {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}

와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로

- {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}
- {{2, 1, 3, 4}, {2}, {2, 1, 3}, {2, 1}}
- {{1, 2, 3}, {2, 1}, {1, 2, 4, 3}, {2}}

는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다.

특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.

#### **[제한사항]**

- s의 길이는 5 이상 1,000,000 이하입니다.
- s는 숫자와 '{', '}', ',' 로만 이루어져 있습니다.
- 숫자가 0으로 시작하는 경우는 없습니다.
- s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다.
- s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다.
- return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다.

------

##### **[입출력 예]**

| s                                 | result       |
| --------------------------------- | ------------ |
| `"{{2},{2,1},{2,1,3},{2,1,3,4}}"` | [2, 1, 3, 4] |
| `"{{1,2,3},{2,1},{1,2,4,3},{2}}"` | [2, 1, 3, 4] |
| `"{{20,111},{111}}"`              | [111, 20]    |
| `"{{123}}"`                       | [123]        |
| `"{{4,2,3},{3},{2,3,4,1},{2,3}}"` | [3, 2, 4, 1] |

##### **입출력 예에 대한 설명**

##### **입출력 예 #1**

문제 예시와 같습니다.

##### **입출력 예 #2**

문제 예시와 같습니다.

##### **입출력 예 #3**

(111, 20)을 집합 기호를 이용해 표현하면 {{111}, {111,20}}이 되며, 이는 {{20,111},{111}}과 같습니다.

##### **입출력 예 #4**

(123)을 집합 기호를 이용해 표현하면 {{123}} 입니다.

##### **입출력 예 #5**

(3, 2, 4, 1)을 집합 기호를 이용해 표현하면 {{3},{3,2},{3,2,4},{3,2,4,1}}이 되며, 이는 {{4,2,3},{3},{2,3,4,1},{2,3}}과 같습니다.

# 내가 생각하는 문제 풀이 포인트

1. 파싱
   1. split 메서드를 이용하여 파싱하였다. 
   2. Stringtokenizer도 써도 될것 같다.
2. set사용
   1. 정렬후 원래 존재하던 수는 앞쪽 새롭게 추가되는 수는 뒤쪽으로 배치해야 돼서 set을 통해 들어올때마다 set에 넣어서 판별하였다.

# 코드

~~~java
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;

public class Solution {
    public static int[] solution(String s) {
        int[] answer;
        HashSet<Integer> set = new HashSet<>();


        s = s.substring(2,s.length()-2).replace("},{","-");
        String[] list = s.split("-");
        Arrays.sort(list, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o1.length() - o2.length();
            }
        });

        answer = new int[list.length];

        for(int i=0;i<list.length;i++){
            String[] values = list[i].split(",");
            for(int j=0;j<values.length;j++){
                int num = Integer.parseInt(values[j]);
                if(!set.contains(num)){
                    set.add(num);
                    answer[i] = num;
                    //System.out.println(num);
                }
            }
        }
        return answer;
    }
}

~~~



# 느낀점

자바가 훨씬 c++보다 string 처리가 쉬웠다. 그리고 처음으로 sort시 compare함수를 커스텀 해보았는데 나름 쉬웠다. 

하지만 ide의 힘을 빌려 코딩을 하는 경향이 커서 실제 복붙이 불가능한 코테를 대비해서 직접 치는 연습도 어느정도 수행해야겠다.. 아니면 ide를 켜놓고 따라치는 방법을 사용해야 될것 같다. 



[문제 링크](https://programmers.co.kr/learn/courses/30/lessons/64065?language=java)