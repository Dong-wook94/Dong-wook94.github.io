---
layout: post
title: "백엔드 면접질문"
subtitle: "백엔드 면접 예상질문 정리"
categories: cs
tags: 백엔드 backend interview 면접
comments: true
---

> 백엔드 주요 면접질문을 모아 답변을 달아보며 추가로 궁금증이 생길만한 추가질문을 스스로 만들어 꼬리질문을 해보았습니다.

## Q1. 자바란?

JAVA는 미국의 선 마이크로 시스템즈가 개발한 객체 지향 언어이다.

자바의 특징으로는

1. **운영체제에 독립적**이다.(JVM만 설치하면)

2. OOP의 특징인 캡슐화, 상속, 다형성이 있다

3. 보안성이 뛰어나다.

4. Garbage Collector가 자동적으로 메모리를 관리해준다.

5. 멀티 쓰레드를 지원한다.

6. 미리 설치되지 않는 프로그램이 서버로부터 동적으로 다운로드 되어 웹 브라우저에서 실행할 수 있도록 동적인 성능 확장을 제공한다.

7. 분산 환경에 적합하여 네트워크 수행 능력이 뛰어나다.



## Q2. http 프로토콜에 대해서 설명해 주세요

* HTTP(Hypertext Transfer Protocol)는 인터넷상에서 데이터를 주고 받기 위한 **서버/클라이언트 모델**을 따르는 프로토콜이다.

* 애플리케이션 레벨의 프로토콜은 TCP/IP위에서 작동한다. 

* HTTP는 어떤 종류의 데이터든지 전송할 수 있다. 

### Q2-1. 작동방식은?

클라이언트에서 요청을 보내면 서버는 요청을 처리해서 응답을 보냅니다. 

### Q2-2. Http의 주요 특징은?

1. **Connectionless** : 연결이 지속 되지 않는다. 요청을 해서 응답을 받으면 연결을 끊어버린다. 
   * 헤더에 keep-alive라는 값을 줘서 커넥션을 재활용 하는데 HTTP1.1에서는 이게 디폴트다. 
2. **Stateless** : 
   * 불특정 다수를 대상으로하는 서비스에 적합하다. 접속을 필요할때만 연결하고끊으니까 더많은 유저의 요청을 처리할 수 있다.
   * 클라이언트의 이전 상태를 알 수가 없다. 그래서 http요청을 보낼때 마다 해당 요청을 처리하기 때문에 모든 데이터를 매번 보내야한다. 이를 해결하기위해서 cookie나 session을 사용하여 데이터를 처리한다.

### Q2-3. 쿠키와 세션의 차이?

일단 쿠키와 세션을 이용하는 이유는 http 프로토콜의 특징이자 약점인 connectionless, stateless 성질 때문이다. 

* 쿠키란
  * **쿠키**는 클라이언트의 상태정보를 로컬에 저장했다가 참조한다.
  * 클라이언트에 300까지 쿠키가 저장가능하다고 한다. 하나의 쿠키 값은 4KB까지 저장한다. 
  * Response Header에 Set-cookie 속성을 이용하면 쿠키를 만들 수 있다. 
  * 사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징이 있습니다.

* 쿠키의 동작 방식

  1. 클라이언트가 페이지를 요청

  2. 서버에서 쿠키를 생성

  3. HTTP 헤더에 쿠키를 포함 시켜 응답

  4. 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음

  5. 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄

  6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답

* 세션이란? 

  * 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버 측에서 관리합니다.
  * 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지.
  * 접속 시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않게 설정이 가능.
  * 세션도 쿠키를 기반으로하긴함.
  * 동접자수가 많은 웹사이트의 경우 서버에 과부하를 주게 되므로 성능저하의 요인이 된다.
  * 보안면에서 쿠키보다 우수하다.
  * 클라이언트가 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는데 이것이 세션 ID이다. 

* 세션의 동작 방식

  1. 클라이언트가 서버에 접속 시 세션 ID를 발급받습니다.
  2. 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있습니다.
  3. 클라리언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 서버에 전달해서 사용합니다.
  4. 서버는 세션 ID를 전달 받아서 별다른 작업없이 세션 ID로 세션에 있는 클라언트 정보를 가져옵니다.
  5. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답합니다.

### Q2-4. 캐시란?

* 캐시는 이미지나 css, js파일 등을 브라우저나 서버 앞 단에 저장해놓고 사용하는 것이다.

## Q3. Restful API란?

Rest 기반의 규칙들을 지켜서 설계된 API를 Rest API 혹은 Restful API이라고 한다.

### Q3-1. REST의 특징.

1. **Uniform Interface (유니폼 인터페이스)**
   `HTTP` 표준만 따른다면 어떤 언어 혹은 어떤 플랫폼에서 사용하여도 사용이 가능한 인터페이스 스타일이다.
   안드로이드 플랫폼, IOS 플랫폼 등 특정 언어나 플랫폼에 종속되지 않고 사용이 가능하다.
2. **Stateless (상태 정보 유지 안함)**
   `Rest`는 상태 정보를 유지하지 않는다.
   서버는 각각의 요청을 완전히 다른 것으로 인식하고 처리를 한다.
   이전 요청이 다음 요청 처리에 연관이 되면 안된다.
3. **Cacheable (캐시 가능)**
   `HTTP`의 기존 웹 표준을 그대로 사용하기 때문에 `HTTP`가 가진 캐싱 기능 적용이 가능하다.
4. **Self-descriptiveness (자체 표현 구조)**
   `Rest API` 메시지만 보고도 쉽게 이해할 수 있는 자체 표현 구조로 되어있다.
5. **Client-Server**
   `Rest` 서버는 `API` 제공을 하고 클라이언트는 사용자 인증에 관련된 일들을 직접 관리한다.
   자원이 있는 쪽을 Server라고 하고 자원을 요청하는 쪽이 Client가 된다.
   서로간의 의존성이 줄어들기 때문에 역할이 확실하게 구분되어 개발해야할 내용들이 명확해진다.
6. **Layerd System (계층화)**
   클라이언트는 `Rest API` 서버만 호출한다.
   `Rest` 서버는 다중 계층으로 구성될수 있으면 로드 밸런싱, 암호화, 사용자 인증 등을 추가하여 구조상의
   유연성을 둘 수 있다.

## Q4. 자바8의 주요 변경사항

1. **Lambda expressions**
   * 람다 표현식은 Anonymous Function라고 할 수 있다.
   * 람다를 이용하여 코드를 간결하게 할 수 있다.
2. **Method Reference**
   * 특정 람다 표현식을 축약한 것으로 볼 수 있다.
   * 메서드 정의를 활용하여 람다처럼 사용 가능하다.
     ![img](https://t1.daumcdn.net/cfile/tistory/99B13C3D5C98EE900E)
3. **Stream API**
   * 간결하게 컬렉션의 데이터를 처리하는 기능.
   * Parallel Stream
     - 위 Stream을 병렬로 처리가능하도록 하는 기능
     - 여러 쓰레드에서 처리할 수 있도록 분할한 Stream 이다.
   * 스트림의 구조 3가지
     * 스트림생성
     * 중개연산
       * filter, map, peek, sorted, limit, distinct, skip...
     * 최종연산 
       * forEach, collect, reduce , iterator, count, min, max, sum,average ...
     * Collections같은 객체 집합.스트림생성().중개연산().최종연산(); 이런식으로 사용.
4. **Default Method**
   - 인터페이스의 구현체를 인터페이스 자체에서 기본으로 제공
   - 구현 클래스에서 인터페이스를 구현하지 않아도 된다.
   - java8에서의 인터페이스와 추상클래스의 차이점
     - 추상 클래스는 인스턴스 변수로 공통상태를 가짐. 반면 인터페이스는 변수(필드)를 가질 수 없다.
     - 추상클래스는 하나만 상속가능하지만 인터페이스는 여러 개를 구현 가능.
     - 디폴트 메서드를 포함하는 인터페이스를 여러 개 구현할 수 있다는 것은 자바에서도 다중 상속을 지원하게 되었다는 뜻.

### Q4-1. 스트림을 사용한 경우에 발생할 수 있는 문제점은?

* 가독성, 간편성, 성능 등의 장점이 있지만 
* 병렬스트림은 여러쓰레드가 처리해준다. 여러쓰레드가 스트림에서 요소를 필터링하고 나온 요소수를 계산하고 
  다시한번 각자 계산한 count 값들을 더해서 리턴해준다.그래서 요소수가 적을때는 오히려 병렬쓰레드를 쓰는게 오버헤드가 클 수 있다. 
* 중개연산은 미리 하지 않는다. 지연 연산을 한다. forEach같은 최종연산이 적용될때 적용해야 두번순회하는 비효율적인 짓을 안하게 된다. 

## Q5. JVM에서 가비지 컬렉터는 어떻게 작동하는지?

GC의 과정을 `Mark and Sweep`이라고도 한다. GC가 스택의 모든 변수 또는 Reachable 객체를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾는 과정이 **Mark**라고 한다. 이 과정에서 Stop the world가 발생한다. 이후 Mark 되어있지 않은 객체들을 힙에서 제거하는 과정이 **Sweep**이다.

## Q6. 세션을 데이터베이스를 이용하지 않고 유지하는 방법

## Q7. 자바에서 싱글톤 패턴을 사용하는 이유?

> 일단 싱글톤패턴이란 전역변수를 사용하지 않고 객체를 하나만 생성하도록 하며 , 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴.

1. 객체를 여러번 생성하지 않아도 되기 때문에 그에 따르는 비용이 적다. 
2. 객체가 무조건 한번만 생성되는 것을 보장 할 수 있다.
3. 한번 만들어져서 여러곳에서 사용하면 수정하기 힘들다.
4. test 하기 어렵다.

## Q8. 동기 비동기에 대해 설명하고 장단점을 설명해 보세요

동기 : 작업의 완료여부를 신경쓴다. 블로킹과 함께 많이쓴다.

비동기 : 작업의 완료여부를 신경쓰지 않는다. 논블로킹방식과 함께 많이쓴다.

블로킹 : 호출되는 함수가 자신의 작업을 모두 끝낼 때 까지 제어권을 가지고 있어서 호출한 함수가 대기하도록 만든다.

논 블로킹: 호출되는 함수가 바로 리턴해서 호출한 함수에게 제어권을 주어서 다른 일을 할 수 있게한다. 

## Q9. DB클러스터링과 리플리케이션의 차이점에 대해 설명해 보세요

## Q10. 스프링을 사용하는 이유?

- 스프링은 자바 및 JVM 환경의 대체언어들의 효율적이고 쉬운 엔터프라이즈 애플리케이션 개발 환경을 제공한다.
- 스프링은 만들고자하는 애플리케이션의 요구사항과 목적에 따라 유연하게 적용시킬수 있습니다.
- 스프링은 패키지들간의 순환 의존성이없는 깨끗한 프로젝트구성을 만들수 있다.
- 스프링은 직관적인 API를 제공한다.
- 스프링은 오픈소스로써 지속적인 업데이트가 되고 있으며 이전 버전들에대한 강력한 호환성을 지원한다.

## Q11. 프로세스와 스레드의 차이

* 프로세스간의 자원공유는 프로세스통신(파이프, 파일, 소켓등의 통신방법을 사용한다)을 통해서! 그리고 다른프로세스의 메모리에 직접 접근이 불가능하다.

* 같은 프로세스내의 스레드 끼리는 스택이외의 데이터영역, 힙영역 등을 공유하기 때문에 자원공유가 용이하다.

## Q12. Call by value, Call by reference의 차이점에 대해 설명해 보세요.

* call by value : 값에 의한 호출 : 복사하여 처리하기 때문에 안전하다 원래의 값은 보존이 된다. 근데 그만큼 메모리의 사용량은 늘어난다.
* call by reference : 복사하지 않고 직접 참조를 하기에 빠르다. 직접참조하기에 원래의 값이 영향을 받는다 리스크가 크다.

## Q13. JVM이 하는일

JVM은 자바를 실행하기 위한 가상 기계입니다. 자바의 바이트 코드를 운영체제에 맞게 해석해주는 역할을 하는데요.

자바 컴파일러가 .java 파일을 컴파일 하면, .class라는 자바 바이트 코드로 변환시켜줍니다. 이때 바이트 코드가 기계어가 아니기 때문에 운영체제에서 바로 실행이 되지 않습니다. 이때 운영체제가 이해할 수 있도록 해석해주는 것이 JVM입니다.

## Q14. 가비지 컬렉션에대해 설명해 보세요 

GC는 Garbage Collection으로, 힙 영역에서 메모리 부족 현상을 해결하기 위해 쓰이지 않는 객체를 해제하는 작업이다.
(1)사용하는 객체를 **mark**하고 (2) mark되지 않는 객체를 **제거**하고 (3) full GC의 경우 제거함으로써 생기는 hole을 **압축**(Compact)한다.
모든 종류의 GC에서 STW가 발생한다.

- Miner GC : 사용되지 않는 객체는 제거되고, 살아남은 객체만 survivor 1, 2 영역으로 이동. 오래 살아남은 객체는 old 영역으로 이동한다.
- Major GC(full GC) : 단편화를 줄이기 위해 hole을 모으는 과정에서 STW가 발생한다.

## Q15. factorial을 재귀로도 짜보고 반복으로도 짜보세요

재귀

~~~java
public static int fibo(int n){
  if(n<=1)
    return n;
  return fibo(n-1)+fibo(n-2);
}
~~~

반복

~~~java
public static int fibo(int n){
  int[] f = new int[n];
  f[0] = 0;
  f[1] = 1;
  if(n>2){
    for(int i=2;i<=n;i++){
    	f[i] = f[i-1]+f[i-1];
  	}
  }
  return f[n];
}
~~~



## Q16. Docker란?

애플리케이션을 컨테이너로서 좀더 쉽게 사용할수 있게 만들어진 오픈소스 프로젝트

### Q16-1. 가상머신과 도커 컨테이너의 차이

게스트 os가 없다 도커컨테이너는 그래서 호스트os의 시스템 콜을 직접 호출한다. 

도커이미지에 서버 운영을 위한 프로그램과 라이브러리들이 포함되어 있는데 이런 이미지들은 도커로 각각 격리되어 설치된다. 

도커엔진이 도커 이미지를 설치할때 마치 가상머신처럼 분리시켜준다. 하지만 호스트 OS는 공유한다.

### Q16-2. 도커 허브란?

도커는 이미지 생성과 배포에 특화된 기능을 제공하는데 이걸 깃처럼 이용하면 이미지를 pull/push할 수 있다. 

이것들을 공유하는 github같은 도커허브가 제공된다.

### Q16-3. 도커 이미지와 컨테이너의 차이

도커이미지는 베이스 이미지에서 몇가지 라이브러리나 프로그램 소스코드등을 추가/설치/저장한 이미지이다. 

컨테이너는 이미지가 실행된 상태

### Q16-4. 도커 컴포즈란?

컨테이너 옵션들을 설정한 파일 , 도커 컴포즈가 없다면 도커 실행명령(run)뒤에 옵션으로 길게 붙여서 실행해야된다. 

도커 컴포즈를 사용하면 빌드와 실행시 명령어가 간단해진다.

## Q17. TDD란?

테스트를 먼저 만들고 테스트를 통과하기 위한 것을 짜는 것 즉, 만드는 과정에서 우선 테스트를 작성하고 그걸 통과하는 코드를 만들고를 반복하면서 제대로 동작하는지에 대한 피드백을 적극적으로 받는 것이다.

## Q18. OOP란?

> 객체지향 프로그래밍 
>
> 객체지향은 사람의 추상능력, 인식방법에 가까운 개발 방법론. attributes와 behavior로 이루어진 객체를 만드는것.

### Q18-1 OOP의 특징

* 추상화
  * 객체의 공통적인 특징을 파악해 하나의 개념(클래스)으로 다루는 것.
* 상속
  * 상위 개념을 하위 개념이 물려받아 재사용성을 높인다. 상속대상은 부모의 필드와 메서드.
* 캡슐화
  * 일반적으로 연관 있는 변수와 함수를 클래스로 묶는 작업을 말합니다. 정보은닉의 특징도 가지고 있어서 접근제어자를 이용하여 중요한 데이터나 기능을 외부에서 접근하지 못하게 할 수 있다.
* 다형성
  * 같은 타입이지만 실행 결과가 다양한 객체를 대입 할 수 있는 성질.
    * 오버라이딩과 오버로딩이 대표적이다.

### Q18-2. SOLID란?

> 객체지향개발의 5대 원리

객체지향 개발의 디자인 원리들을 사용하면 좀 더 유지보수하기 쉽고, 유연하고, 확장이 쉬운 소프트웨어를 만들 수 있습니다.

- 5가지 원리의 핵심 내용
  1. **단일 책임 원칙 (Single Responsibility Principle)**
     - **모든 클래스는 각각 하나의 책임만 가져야 한다.** 클래스는 그 책임을 완전히 캡슐화 해야 한다.
  2. **개방 - 폐쇄 원칙 (Open Closed Principle)**
     - 확장에는 열려 있고 수정에는 닫혀있는, **기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계** 가 되어야 한다는 원칙.
  3. **리스코프 치환 원칙 (Liskov Substitution Principle)**
     - **자식 클래스는 언제나 자신의 부모 클래스를 대체 할 수 있다는 원칙.**
     - 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의 하지 않고 확장만 수행하도록 해야 LSP 를 만족한다.
  4. **인터페이스 분리 원칙 (Interface Segregation Principle)**
     - 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
     - **하나의 일반적인 인터페이스보다는 여러개의 구체적인 인터페이스가 낫다.**
  5. **의존 역전 원칙 (Dependency Inversion Principle)**
     - 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것.
     - 말이 너무 추상적이라 정리하자면, **구체적인 클래스보다 인터페이스나 추상클래스와 관계를 맺으라는 것.**

## Q19. 클린코드란?

가독성이 좋은 코드, 다른사람이 고치기쉽고 이해하기 쉬운 코드

테스트를 작성한 코드

단위가 작은 코드

## Q20. CI/CD 에대해 각각 설명해 주세요

- CI/CD는 애플리케이션 개발 단계를 자동화하여 애플리케이션을 보다 짧은 주기로 고객에게 제공하는 방법이다.
- 지속적인 통합, 지속적인 서비스 제공, 지속적인 배포를 가능하게 한다.
- 새로운 코드의 통합으로 인하여 개발 및 운영팀에 발생하는 문제를 해결하는 솔루션이다.

* CI 
  * Build & Packaging
  * 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트되어 공유 리포지토리에 병합되는 것이다.
  * Build, Test를 실시하는 프로세스를 말하며 이러한 통합 프로세스를 상시로 실시하는 것이다.
* CD
  * Deployment
  * 개발자들이 애플리케이션에 적용한 변경 사항이 버그 테스트를 거쳐 리포지토리에 자동으로 업로드되는 것이다.
  * 개발자의 변경 사항을 리포지토리에서 고객이 사용 가능한 프로덕션 환경까지 자동으로 릴리스하는 것이다.
* 장점
  * 모든 분기의 소스 코드를 병합하는 경우, 결과적으로 반복적인 수작업에 많은 시간이 소요된다.
  * 병합하는 수작업을 하지 않는다면, 개발자가 애플리케이션에 변경 사항을 적용할 때 다른 개발자가 동시에 적용하는 변경 사항과 충돌할 수 있다.
  * 자동화된 테스트에서 기존 코드와 신규 코드 간의 충돌이 발견되면 CI를 통해 이러한 버그를 더욱 빠르게 자주 수정할 수 있다.
  * 여러 사람이 작성한 코드가 병합되었을 때 생기는 문제를 미리 감지한다.
  * System과 Application을 최대한 최신 상태로 유지할 수 있다.

## Q21. 브라우저에서 서버까지의 응답 흐름. 

1. 브라우저의 url 파싱 후 분석
   1. 어떤 프로토콜을 통해 해당 url에 요청할지
   2. 어떤 url 로 요청할지
   3. 어떤 포트로 요청할 것인지
2. url을 ip주소로 변환.
   * **DNS 서버로 요청하는 과정** 
     1.  미리 설정 된 Local DNS에 해당 URL 주소의 IP주소를 요청합니다.
     2.  Local DNS에 해당 IP주소가 존재한다면 이를 응답하고, 없다면 다른 DNS 서버와 통신합니다. root DNS 서버에 해당 URL의 IP주소를 요청합니다.
     3. root DNS서버에 해당 IP주소가 없다면 하위 DNS 서버에 요청하라고 응답합니다. 이 응답을 받은 Local DNS는. net 도메인을 관리하는 DNS 서버에 같은 내용을 요청합니다.
     4. .net DNS 서버에 해당 IP주소가 없다면 하위 DNS 서버에 요청하라고 응답합니다. 이 응답을 받은 Local DNS는 daum.net 도메인을 관리하는 DNS 서버에 같은 내용을 요청합니다.
     5. daum.net DNS 서버에서 IP주소를 응답받은 Local DNS는 해당 IP주소를 캐싱하고 응답합니다.
3. 라우터를 통해 해당 서버의 게이트웨이 까지 이동
4. ARP를 통해 IP주소를 MAC주소로 변환
5. 대상 서버와 TCP 소켓 연결
6. HTTP 프로토콜로 요청, 응답
7. 브라우저에서 응답을 해석후 보여주기

## Q22. DTO , DAO 의 차이

DAO : Database의 data에 access하는 트랜잭션 객체.

DTO : VO(Value Object)로 바꿔 말할 수 있는데 계층간 데이터 교환을 위한 자바빈즈를 말한다.

## Q23. 아는 정렬 알고리즘에 대해 설명해 주세요.

| Sorting   | In-Place | Stable | Comparison | Time Complexity |
| --------- | -------- | ------ | ---------- | --------------- |
| Selection | ○        | ×      | ○          | O(n^2)          |
| Bubble    | ○        | ○      | ○          | O(n^2)          |
| Quick     | ○        | ×      | ○          | O(nlogn)        |
| Insertion | ○        | ○      | ○          | O(n^2)          |
| Shell     | ○        | ×      | ○          | O(n^2)          |
| Merge     | ×        | ○      | ○          | O(nlogn)        |
| Radix     | ×        | ○      | ×          | d * O(n)        |
| Heap      | ○        | ×      | ○          | O(nlogn)        |

## Q24. PCB에 저장되는 정보는 어떤것들이 있나요?

> PCB : Process Control Block 
>
> * 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳으로, 프로세스의 상태 정보를 저장하는 구조체이다.
> * 프로세스 상태 관리와 문맥교환(Context Switching)을 위해 필요하다.
> *  PCB는 프로세스 생성 시 만들어지며 주기억장치에 유지된다.

● PID : 프로세스의 고유 번호

● 상태 : 준비, 대기, 실행 등의 상태

● 포인터 : 다음 실행될 프로세스의 포인터

● Register save area : 레지스터 관련 정보

● Priority : 스케줄링 및 프로세스 우선순위

● 할당된 자원 정보

● Account : CPU 사용시간, 실제 사용된 시간

● 입출력 상태 정보

## Q25. Context Switching에 대해 설명해 주세요.

- 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정을 말합니다.

### Q25-1. 어떻게 Context Switching은 진행될까요?

- Task의 대부분 정보는 Register에 저장되고 PCB(Process Control Block)로 관리되고 있습니다.
- 현재 실행하고 있는 Task의 PCB 정보를 저장하게 됩니다. (Process Stack, Ready Queue)
- 다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행을 할 수 있습니다.

## Q26. OOP를 지향하기위해 어떤 노력을 할수 있나요?

SOLID의 원칙을 지켜 개발한다. (위에 정리해놓음.)

## Q27. TCP와 UDP의 차이.

| 프로토콜 종류  | TCP            | UDP                      |
| -------------- | -------------- | ------------------------ |
| 연결 방식      | 연결형 서비스  | 비연결형 서비스          |
| 패킷 교환 방식 | 가상 회선 방식 | 데이터그램 방식          |
| 전송 순서      | 전송 순서 보장 | 전송 순서가 바뀔 수 있음 |
| 수신 여부 확인 | 수신 여부 확인 | 수신 여부 확인하지 않음  |
| 통신 방식      | 1:1 통신       | 1:1 or 1:N or N:N 통신   |
| 신뢰성         | 높다           | 낮다                     |
| 속도           | 느리다         | 빠르다                   |

## Q28. Connectoin pool 을 사용하는 이유는?

**커넥션풀**이란 단순하게 말하자면 **나중을 대비해서 미리 커넥션을 10개 정도 생성을 해놓는 것**을 말합니다.

그리고 나서 필요할때마다 가져다 쓰는 것.

풀 속에 미리 커넥션이 생성되어 있기 때문에 커넥션을 생성하는 데 드는 연결 시간이 소비되지 않는다.

## Q29. 재귀의 장점과 단점.

장점

1. 알고리즘 자체가 재귀적으로 표현하기 자연스러울 때. (가독성 이야기)
2. 변수 사용을 줄여 준다.

단점

1. 기본적으로 스택메모리를 사용하는데 재귀의 깊이가 깊어졌을때, stack overflow가 발생할 수 있다.

## Q30. GET과 POST의 차이

- GET: 데이터 조회, 쿼리로 요청 데이터를 전송하며, 외부에 노출된다.
- POST: 데이터 추가(생성), request body 안에 전송할 데이터를 넣어 전송한다. 데이터는 외부에 노출되지 않는다.

## Q31. HTTP와 HTTPS의 차이

 HTTPS는 쉽게 말해서 HTTP 프로토콜에 보안 기능을 추가한 것.

HTTPS는 인터넷 상에서 정보를 암호화하는 SSL(Secure Socket Layer)프로토콜을 이용하여 웹브라우저(클라이언트)와 서버가 데이터를 주고 받는 통신 규약

## Q32. 데이터베이스에서 왜 여러 테이블을 두는지?

**정규화**를 하는 이유랑 같다고 본다. 중복을 최소화하고 데이터를 구조화 하기 위해 정규화 과정을 거쳐 테이블을 여러개 두는 것이라고 생각한다. 정규화를 좀더 구체적으로 설명하자면 불만족스러운 ‘나쁜’ 릴레이션의 애트리뷰트들을 나누어서 ‘좋은’ 작은 릴레이션으로 분해하는 작업을 말한다.

### Q32-1. 나쁜 릴레이션은 어떻게 파악하는가?

엔티티를 구성하고 있는 애트리뷰트 간에 함수적 종속성을 판단한다. 판단된 함수적 종속성(Functional Dependency)은 좋은 릴레이션 설계의 정형적 기준으로 사용된다. 즉, 각각의 정규형마다 어떠한 함수적 종속성을 만족하는지에 따라 정규형이 정의되고, 그 정규형을 만족하지 못하는 정규형을 ‘나쁜' 릴레이션으로 파악한다.

### Q32-2. 함수적 종속성이란 무엇인가?

함수적 종속성이란 애트리뷰트 데이터들의 의미와 애트리뷰트들 간의 상호 관계로부터 유도되는 제약조건의 일종이다.  X와 Y를 임의의 애트리뷰트 집합이라고 할 때, X의 값이 Y의 값을 유일하게(unique) 결정한다면 “X는 Y를 함수적으로 결정한다”라고 한다.

### Q32-3. 각 정규형은 어떠한 조건을 만족해야 하는 가?

**제 1 정규형**

모든 도메인이 원자값(Atomic Value)만으로 구성되도록 하는 정규형을 말한다. 각 칼럼은 atomic해야한다.

**제 2 정규형**

모든 비주요 애트리뷰트들이 주요 애트리뷰트에 대해서 **완전 함수적 종속**이면 제 2 정규형을 만족한다고 볼 수 있다. 완전 함수적 종속이란 X->Y 라고 가정했을 때, X의 어떠한 애트리뷰트라도 제거하면 더 이상 함수적 종속성이 성립하지 않는 경우를 말한다. 즉, 키가 아닌 열들이 각각 후보키에 대해 결정되는 릴레이션 형태를 말한다.

**제 3 정규형**

어떠한 비주요 애트리뷰트도 기본키에 대해서 **이행적으로 종속되지 않으면** 제 3 정규형을 만족한다고 볼 수 있다. 이행 함수적 종속이란 X->Y, Y->Z의 경우에 의해서 추론될 수 있는 X->Y의 종속관계를 말한다. 즉, 비주요 애트리뷰트가 비주요 애트리뷰트에 의해 종속되는 경우가 없는 릴레이션 형태를 말한다.

**BCNF(Boyce-Codd) 정규형**

모든 결정자가 키인 경우 BCNF.

## Q33. Inner Join과 Outer Join에 대해 설명해 주세요.

**Inner Join**은 서로 매칭되는 것만 엮어 조회한다.

**Outer Join**은 매칭 뿐만 아니라 미매칭 데이터도 함께 조회한다.

## Q34. git hub의 장점은?

- 효과적인 협업
- 손쉬운 개발 및 테스트 환경 구축
- 효율적인 배포관리
- 버전관리

## Q35. 코드스멜이란?

작성한 소스 코드에 문제가 있음을 나타내는 어떤 낌새. 리팩토링이 필요한 코드.

## Q36. 로컬스토리지에 대해 설명해 주세요

*  cookies와는 달리모든 HTTP 요청에서 데이터를 주고받을 필요가 없다
* 데이터가 유저의 로컬 디스크에 저장되어 있으면 인터넷이 끊어져도 데이터가 삭제되거나 지워지지 않는다.
* LocalStorage의 만료 조건은 persistent cookies처럼 동작합니다. 

## Q37. HTTP 메서드에 대해서 각각 설명해 주세요?

get -조회 ,post - 생성,put - 변경, delete - 삭제

## Q38. 뮤텍스와 세마포어의 차이점

- 세마포어는 공유 자원에 **세마포어의 변수만큼의 프로세스(또는 쓰레드)가 접근**할 수 있습니다. 반면에 뮤텍스는 **오직 1개만의 프로세스(또는 쓰레드)만 접근**할 수 있습니다.
- 현재 수행중인 프로세스가 아닌 **다른 프로세스가 세마포어를 해제할 수 있습니다.** 하지만 뮤텍스는 **락(lock)을 획득한 프로세스가 반드시 그 락을 해제**해야 합니다.

## Q39. CLOSE_WAIT, TIME_WAIT에 대해 설명 해 주세요.

**CLOSE_WAIT** : Close 명령을 실행 할 때까지 기다리는 상태 

**TIME_WAIT** : 두가지 상황에 대비해 사용한다.

1. 즉시 연결을 종료하고 바로 다음 연결을 맺였을 때, 

첫번째 연결했을때의 데이터 패킷이 뒤늦게 도착하여 Sequence ID가 꼬이는 것을 방지

2. 마지막 ACK 패킷이 손실 되어 Active Close 혼자 연결을 Disconnect 해버리는 경우.



추가적을 **FIN_WAIT**

Active Close 대상이 Passive Close로 부터 FIN패킷을 기다리는 상태를 FIN_WAIT2 상태라 합니다.

이때, 일정 시간 FIN이 오지 않으면, 자동으로 TIME_WAIT 로 넘어가는 특징이 있습니다.

## Q40. Web Server 와 WAS의 차이점

웹서버는 브라우저 클라이언트로부터 http 요청을 받아 정적인 컨텐츠(.html .jpeg  .css)를 제공하는 컴퓨터 프로그램

WAS는 DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어지 Application Server. 웹 컨테이너 혹은 서블릿 컨테이너 라고도 불린다.

WAS = WebServer + Web Container

WAS의 주요기능 

1. 프로그램 실행환경과 DB 접속 기능 제공.
2. 여러개의 트랜잭션(논리적인 작업단위) 관리기능
3. 업무를 처리하는 비즈니스 로직 수행.

## Q41. 웹소켓이란?

## Q42. SSE란?

## Q43. 응집도와 결합도의 차이.

## Q44. HTTP 이외에 아는 프로토콜?

## Q45. 스프링에서 AOP란?

> 흩어진 aspect 를 모아서 모듈화 하는 기법.

**AOP**는 **Aspect Oriented Programming**의 약자로 **관점 지향 프로그래밍**이라고 불린다. 관점 지향은 쉽게 말해 **어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하겠다는 것이다**. 여기서 모듈화란 어떤 공통된 로직이나 기능을 하나의 단위로 묶는 것을 말한다. 

**스프링 AOP 특징**

- **프록시 패턴 기반의 AOP 구현체**, 프록시 객체를 쓰는 이유는 접근 제어 및 부가기능을 추가하기 위해서임
- 스프링 빈에만 AOP를 적용 가능
- 모든 AOP 기능을 제공하는 것이 아닌 스프링 IoC와 연동하여 엔터프라이즈 애플리케이션에서 가장 흔한 문제(중복코드, 프록시 클래스 작성의 번거로움, 객체들 간 관계 복잡도 증가 ...)에 대한 해결책을 지원하는 것이 목적.

## Q46. IOC란?

메서드나 객체 호출같은 작업을 개발자가 결정하는 것이아니라 그냥 프레임워크 내부에서 결정한 대로 이루어 지는것.  직역하면 제어의 역전. 개발자는 그냥 프레임워크에 필요한 부품만 개발하면 된다. 

이게 필요한 이유는 배포하고나서는 개발자가 직접 객체의 생성이나 사용등을 제어할수 가없는데 그걸 컨테이너가 알아서 해주는 것이다. 적절한 시점에 서블릿에 대한 제어권한을 가진 컨테이너가 서블릿 클래스의 객체를 만들고 그안의 메서드를 호출한다. 

## Q47. 스프링과 스프링 부트의 차이점

## Q48. 박싱과 언박싱

박싱 : primitive -> wrapper클래스

언박싱 : wrapper -> primitive 

## Q49. pojo가 무엇인가요?

 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트

## Q50. 쿠버네티스가 하는 일?

분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공

- **서비스 디스커버리와 로드 밸런싱** 쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.
- **스토리지 오케스트레이션** 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재 할 수 있다.
- **자동화된 롤아웃과 롤백** 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.
- **자동화된 빈 패킹(bin packing)** 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.
- **자동화된 복구(self-healing)** 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.
- **시크릿과 구성 관리** 쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리 할 수 있다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트 할 수 있다.

## Q51. 스프링의 MVC에 대해 설명하세요.

## Q52. 스프링 필터와 인터셉터의 차이점.

필터와 인터셉터는 실행되는 시점에서 차이가 있습니다. 필터는 웹 애플리케이션에 등록을 하고, 인터셉터는 스프링의 context에 등록을 합니다. 따라서 컨트롤러에 들어가기 전 작업을 처리하기 위해 사용하는 공통점이 있지만, 호출되는 시점에서 차이가 존재합니다.

## Q53. 제네릭이란?

제네릭은 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능입니다.

즉, **클래스 내부에서 사용할 데이터 타입을 나중에 인스턴스를 생성할 때 확정하는 것**을 **제네릭**이라 합니다.

제네릭의 장점은

1. 컴파일 시 강한 타입 체크를 할 수 있다.
   - 실행시 타입 에러가 나는 것보다 컴파일 시에 미리 타입을 강하게 체크해서 에러를 사전에 방지
2. 타입 변환(casting)을 제거한다.
   - 비제네릭 코드는 불필요하게 타입 변환을 하기 때문에 프로그램 성능에 악영향을 미친다.

> #### 와일드카드란,
>
> 제네릭 클래스의 객체를 메소드의 매개변수로 받을 때, 그 객체의 타입 변수를 제한하는 것을 말한다.
>
> #### 와일드 카드<?>의 제한 종류
>
> - **<? extends T>** 와일드 카드의 상한 제한(upper bound) - T와 그 자손들을 구현한 객체들만 매개변수로 가능
> - **<? super T>** 와일드 카드의 하한 제한(lower bound) -T와 그 조상들을 구현한 객체들만 매개변수로 가능
> - **<?>** 제한 없음

## Q54. 직렬화란?

자바 시스템 내부에서 사용되는 object 또는 data를 외부의 자바 시스템에서도 사용할 수 있도록 byte 형태로 데이터를 변환하는 기술.

## Q55. JDBC가 무엇인가요?

자바에서 데이터베이스를 접속할 수 있도록 해주는 자바 API입니다. JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트 하는 방법들을 제공합니다.

## Q56. 스프링 DI란?

객체에 다른객체를 넣어주는것.

객체를 외부에서 만들어서 넣어주는것 . 스프링에서는 프레임워크에서 알아서 di를 해준다.

스프링이 지원하는 의존성 주입에는 두 가지가 있다.

1. *매개변수 주입식*
   1. 매개변수에서 지정된 타입이 메소드에서 사용될 때 적절히 생성해준 객체를 우리는 New없이 사용한다.
2. *@Autowired 방식*
   * 메소드에서 언급없이 사용되는 객체 변수에 대해서 컨트롤러에 사전에 참조된 @Autowired 방식의 변수를 알맞게 객체 생성하여 사용하도록 한다. 

## Q57. 데드락은 무엇이고 해결방안.

## Q58. 인터페이스와 추상메서드의 차이

abstract class(추상 클래스)와 interface 는 선언만 있고 구현 내용이 없는 클래스이다.

그래서 자기 자신이 new를 해서 객체를 생성할 수 없으며,

추상클래스를 extends 받거나, interface를 implements 한 자식만이 객체를 생성할 수 있다.

상속받은 자식이 구현을 반드시 하도록 해야할 때 사용한다.

**추상클래스**의 정의는 abstract 메소드가 하나라도 존재하는 클래스를 일컫는다.

때문에 일부는 구현된 메소드도 있고, abstract라고 붙어있는 메소드는 구현이 안되어있다.

**인터페이스**는 구현체 없이, 메소드에 대한 명세만 되어있다.

인터페이스를 상속받는 클래스에서는 반드시 인터페이스에 있는 메소드를 다 구현해야한다.

- 인터페이스는 다중 확장 가능, 추상 클래스는 불가
- 인터페이스의 필드값는 static final이지만 추상클래스는 non-static, non-final 필드 가능

## Q59. 가상 메모리란?

* 실제 메모리보다 많이 보이게 하는 기술
* 실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술
* MMU (Memory Management Unit)
  * cpu에 코드 실행시, 가상 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치

### Q59-1. 가상메모리가 필요한 이유?

하나의 프로세스만 실행 가능한 시스템(배치 처리 시스템)에서는 크게 필요가 없다. 

* 프로그램을 메모리로 로드
  * 프로세스 실행
  * 프로세스 종료(메모리 해제)
* 여러 프로세스 동시 실행 시스템에서는 가상메모리가 필수적으로 필요하다
  * .메모리 용량 부족 이슈
  * 프로세스 메모리 영역간에 침범 이슈

## Q60. 세그먼트와 페이징의 차이? 

**페이징: 내부 단편화 O, 외부 단편화 X** , 고정된 영역인 페이지로 분할
**세그먼테이션:** **내부 단편화 X, 외부 단편화 O** , 가변적인 영역인 segment로 분할, 분할영역이 가변적이라 스와핑은 힘들수도 있다.

## Q61. 박싱과 언박싱

원시형을 Wrapper Class로 변환하는 것이 박싱이고,

Wrapper Class를 원시형으로 변환하는 것이 언박싱입니다.



## Q62. 도커란?

컨테이너 기반의 오픈소스 가상화 플랫폼.

### Q62-1. vm과의 차이

도커는 vm과 달리 호스트OS를 공유하며, 여러개의 컨테이너들이 서로 영향을 미치지 않고 독립적으로 실행되어 가볍다.

### Q62-2. 이미지란?

도커 이미지는 특정 프로세스를 실행하기 위한 환경이다.

## Q63. 도커 컴포즈를 사용하는 이유?

## Q64. 쿠버네티스란?

## Q65. pod, replicaset, deployment, ingress 차이

## Q66. spring boot 2.3 주요 변경사항

Q67. 



## Reference

https://shlee0882.tistory.com/107

https://interconnection.tistory.com/74

https://velog.io/@stampid/REST-API%EC%99%80-RESTful-API

https://juyoung-1008.tistory.com/49

https://marobiana.tistory.com/58

https://deveric.tistory.com/97

https://kim6394.tistory.com/161

https://nesoy.github.io/articles/2018-11/Context-Switching

https://asfirstalways.tistory.com/341

https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html